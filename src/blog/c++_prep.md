# Interview Preparation (C++)

On a scale of 1 through 5 (1=basic familiarity, 3=working knowledge,
5=expert), I would rate my programming language proficiencies as
follows:

-   C++: 3
-   elisp: 1
-   Haskell: 1
-   Python: 4
-   R: 3
-   Rust: 2
-   SQL: 2

Languages with a score of 3 or higher go on my
[resume](../static/resume.pdf). The others are ones that I am learning
(elisp, Rust), have learned but forgot much of (SQL), or have put on
hiatus (Haskell).

Of all these languages, the one that I must focus on in the short-term
is C++. I have recently been interviewing for quantitative positions.
And interviewers do not hesitate to prod at the supposed C++ knowledge
of their prospective employees.

### My C++ Experience

My C++ programming experience is purely academic. It comes from the
following Rutgers courses:

-   **ECE 503:** Programming Methodology for Numerical Computing and
    Finance
-   **MATH 623:** Computational Finance

ECE 503 was a mediocre course on basic C++ programming. It felt like an
undergraduate CS 101 course. Moreover, each three-hour session consisted
entirely of the instructor reading off a powerpoint that came bundled
with the textbook. An easy A. And a waste of my time.

MATH 623, however, was an excellent *tour de force* of numerical
analysis taught by a seasoned industry practioner. The course required
weekly programming assignments along with a final project -- all C++.
These assignments typically required implementing some options-pricing
algorithm. My code left much to be desired.

At the end of the program, I was left with a *passable* knowledge of
C++. But I won't consider myself to be a confident C++ programmer. And I
certainly have much to learn before I can produce idiomatic code.

### Skills that need improving

Here are three specific areas that I need to improve on:

-   **Design Patterns.** For better or for worse, C++ is an obligate
    object oriented language. My brain has been trained to seek out
    functional models for computing. And Python (my go-to language) has
    only fed into this habit with lambdas, comprehensions, and
    first-class functions. I *do* understand the semantics of C++'s
    class and template systems, as well as the textbook definitions of
    some common design patterns. However, I lack understanding of the
    *ethos* of idiomatic OO programming. Creaing a practical object
    model can be difficult when one is already working with complex
    mathematical abstractions.
-   **Debugging.** Knowing how to debug code is just as important as
    being able to write it. And C++ has a lot of debugging tools that I
    have yet to familizarize myself with. As a Linux user, the debuggers
    that I have available are primarily *GDB* (for use with g++) and
    *LLDB* (for use with clang). There is also *Valgrind* for memory
    debugging, whatever that is.
-   **Concurrency/GPGPU.** The rise of cloud technologies has reduced
    the barrier of entry for computing at scale. And this has only
    increased the importance (and dangers!) of concurrent programming.
    And now GPU's are being used for general purpose computing, allowing
    programmers to write massively parallelized code with frameworks
    like *OpenCL*.

There are, of course, other important skills: writing concisely,
creating comprehensive documentation, unit testing, version control,
*etc*. But these skills are mostly language-agnostic. And I have learned
much of this writing Python.

### Planning for success

I basically know of two ways to gain some of the aforementioned skills:

-   **Read good C++.** *Code Complete* and *Effective C++* are
    definitely on my short list. But since I'm strapped for time, I may
    have to start with *Cracking the Coding Interview*.
-   **Write good C++.** Perfect practice makes perfect. And the practice
    I've had was far from it. Perhaps I should contribute to an open
    source C++ project. Hopefully, the feedback and constructive
    criticism will improve my skills.

